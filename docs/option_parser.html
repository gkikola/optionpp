<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
          "http://www.w3.org/TR/html4/strict.dtd">
<html>
  <head>
    <title>Option++ - class OptionParser</title>
  </head>
  <body>

    <a href="index.html">Option++</a> >
    <a href="index.html#ref">Classes</a> >
    <code>OptionParser</code>
    
    <h1><code>class OptionParser</code></h1>

    <p>Parses command-line program arguments and stores them as a
    sequence of <a href="option.html"><code>Option</code></a>
    objects. Options may be specified on the command line using a '-'
    followed by a group of short option names, or using a '--'
    followed by a long option name. Arguments to particular options
    are specified with an (optional) '=' symbol after the option name
    followed by the argument value. '--' may be passed by itself as a
    single argument to specify that all remaining arguments are to be
    interpreted as ordinary program arguments and not as program
    options.</p>

    <p>To use the parser, it should be initialized with a collection
    of <a href="option_desc.html"><code>OptionDesc</code></a> objects
    which specify the options accepted by the program. Then
    the <a href="#parse"><code>parse</code></a> method may be called
    with the arguments passed to <code>main</code>. The
    resulting <a href="option.html"><code>Option</code></a> objects
    may then be accessed by iterating over
    the <code>OptionParser</code>. The <a href="#find"><code>find</code></a>
    methods allow the user to check for the presence of a particular
    option. The sequence of regular, non-option program arguments can
    be accessed by iterating over the container returned by
    the <a href="#program_args"><code>program_args</code></a>
    method.</p>
    
    <h2>Member Types</h2>

    <dl>
      <dt><code>desc_set</code></dt>
      <dd>Type of container which can hold the set
      of <a href="option_desc.html"><code>OptionDesc</code></a>
      objects.</dd>
      <dt><code>option_seq</code></dt>
      <dd>Type of container which can hold the sequence
      of <a href="option.html"><code>Option</code></a> objects.</dd>
      <dt><code>arg_seq</code></dt>
      <dd>Type of container which can hold the sequence of non-option
      program arguments.</dd>
      <dt><code>size_type</code></dt>
      <dd>Unsigned type which can store the size of
      an <code>OptionParser</code>'s collection
      of <a href="option.html"><code>Option</code></a> objects.</dd>
      <dt><code>iterator</code></dt>
      <dd>Random-access iterator that can iterate
      over <a href="option.html"><code>Option</code></a> objects.</dd>
      <dt><code>const_iterator</code></dt>
      <dd><code>const</code> random-access iterator.</dd>
      <dt><code>reverse_iterator</code></dt>
      <dd>Reverse random-access iterator.</dd>
      <dt><code>const_reverse_iterator</code></dt>
      <dd><code>const</code> reverse random-access iterator.</dd>
    </dl>

    <h2>Member Functions</h2>

    <dl>
      <dt><a href="#ctor">(constructor)</a></dt>
      <dd>Constructor.</dd>
      <dt><a href="#add"><code>add</code></a></dt>
      <dd>Add a program option to the set of valid options.</dd>
      <dt><a href="#lookup"><code>lookup</code></a></dt>
      <dd>Lookup an option description by name.</dd>
      <dt><a href="#allow_bad_opts"><code>allow_bad_opts</code></a></dt>
      <dd>Tell parser whether to ignore invalid options.</dd>
      <dt><a href="#allow_bad_args"><code>allow_bad_args</code></a></dt>
      <dd>Tell parser whether to ignore option argument
      errors.</dd>
      <dt><a href="#parse"><code>parse</code></a></dt>
      <dd>Parse <code>argv</code> and store list of options that have
      been set.</dd>
      <dt><a href="#size"><code>size</code></a></dt>
      <dd>Return number of program options that have been set.</dd>
      <dt><a href="#empty"><code>empty</code></a></dt>
      <dd><code>true</code> if no options have been set or if the
      parser has not yet been run.</dd>
      <dt><a href="#begin_end"><code>begin</code></a></dt>
      <dd>Iterator pointing to first option read.</dd>
      <dt><a href="#begin_end"><code>end</code></a></dt>
      <dd>Iterator pointing to one past the last option read.</dd>
      <dt><a href="#begin_end"><code>rbegin</code></a></dt>
      <dd>Reverse iterator to beginning.</dd>
      <dt><a href="#begin_end"><code>rend</code></a></dt>
      <dd>Reverse iterator to ending.</dd>
      <dt><a href="#begin_end"><code>cbegin</code></a></dt>
      <dd><code>const</code> iterator to beginning.</dd>
      <dt><a href="#begin_end"><code>cend</code></a></dt>
      <dd><code>const</code> iterator to ending.</dd>
      <dt><a href="#begin_end"><code>crbegin</code></a></dt>
      <dd><code>const</code> reverse iterator to beginning.</dd>
      <dt><a href="#begin_end"><code>crend</code></a></dt>
      <dd><code>const</code> reverse iterator to ending.</dd>
      <dt><a href="#find"><code>find</code></a></dt>
      <dd>Find a particular option in the last of options that have
      been read.</dd>
      <dt><a href="#program_args"><code>program_args</code></a></dt>
      <dd>Return reference to container holding non-option program
      arguments.</dd>
      <dt><a href="#print_usage"><code>print_usage</code></a></dt>
      <dd>Print help message to a <code>std::ostream</code>.</dd>
      <dt><a href="#usage"><code>usage</code></a></dt>
      <dd>Store help message in a string.</dd>
    </dl>

    <h2>Member Functions in Detail</h2>

    <h2 id="ctor"><code>OptionParser::OptionParser</code></h2>

    <code>
      OptionParser();<br>
      OptionParser(std::initializer_list&lt;OptionDesc> opts);
    </code>
    <p>
      Constructs an <code>OptionParser</code> accepting the options
      specified in <code>opts</code>, or accepting no options in the
      case of the default constructor. Options may be added to the set
      of valid options after construction by using
      the <a href="#add"><code>add</code></a> method.
    </p>
    <p>
      Typically the constructor is called with a braced initializer
      list describing the program options, as shown in
      the <a href="index.html#example">example program</a>.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>opts</code></dt>
      <dd>Initializer list
      of <a href="option_desc.html"><code>OptionDesc</code></a>
      objects which describe the options accepted by the program.</dd>
    </dl>

    <h2 id="add"><code>OptionParser::add</code></h2>

    <code>
      void add(const OptionDesc& desc)<br>
      void add(std::initializer_list&lt;OptionDesc> opts);<br>
      void add(char sname, const std::string& lname,
      const std::string& aname, const std::string& desc_str,
      int group = 0);
    </code>
    <p>
      Adds an option or several options to the set of valid options
      accepted by the program.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>desc</code></dt>
      <dd>An <a href="option_desc.html"><code>OptionDesc</code></a>
      object which describes the option to be added.</dd>
      <dt><code>opts</code></dt>
      <dd>Initializer list
        of <a href="option_desc.html"><code>OptionDesc</code></a>
        objects which describe the options that are to be added.</dd>
      <dt><code>sname</code></dt>
      <dd>Short name for the option being added.</dd>
      <dt><code>lname</code></dt>
      <dd>Long name for the option being added.</dd>
      <dt><code>aname</code></dt>
      <dd>Name of the argument, if any, for the option being
        added.</dd>
      <dt><code>desc_str</code></dt>
      <dd>Brief description of what the option does, to be included in
      the generated help message.</dd>
    </dl>

        <h2 id="lookup"><code>OptionParser::lookup</code></h2>

    <code>
      OptionDesc* lookup(char short_name);<br>
      const OptionDesc* lookup(char short_name) const;<br>
      OptionDesc* lookup(const std::string& long_name);<br>
      const OptionDesc* lookup(const std::string& long_name) const;
    </code>
    <p>
      Finds and returns a pointer to
      an <a href="option_desc.html"><code>OptionDesc</code></a> which
      describes the specified program option.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>short_name</code></dt>
      <dd>The short name of the option whose description is to be
        found.</dd>
      <dt><code>long_name</code></dt>
      <dd>The long name of the option whose description is to be
      found.</dd>
    </dl>

    <h4>Return Value</h4>
    <p>
      Pointer to
      an <a href="option_desc.html"><code>OptionDesc</code></a> which
      describes the option with the specified name,
      or <code>nullptr</code> if the option description was not found.
    </p>

    <h2 id="allow_bad_opts"><code>OptionParser::allow_bad_opts</code></h2>

    <code>
      void allow_bad_opts(bool allow = true);
    </code>
    <p>
      Tells the parser whether or not it should ignore errors from
      invalid options. If <code>allow</code> is <code>true</code>,
      then invalid options are allowed.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>allow</code></dt>
      <dd>If set to <code>true</code>, then the parser will allow
      invalid options without raising an error.</dd>
    </dl>

    <h2 id="allow_bad_args"><code>OptionParser::allow_bad_args</code></h2>

    <code>
      void allow_bad_args(bool allow = true);
    </code>
    <p>
      Tells the parser whether or not it should ignore errors from
      invalid option arguments. If <code>allow</code>
      is <code>true</code>, then arguments will be accepted even for
      options that do not normally take arguments. Otherwise,
      providing an argument for an option that takes no argument will
      raise an error.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>allow</code></dt>
      <dd>If set to <code>true</code>, then the parser will allow an
      argument to be given for options that do not normally accept an
      argument.</dd>
    </dl>
    
    <h2 id="parse"><code>OptionParser::parse</code></h2>

    <code>
      void parse(int argc, char* argv[]);
    </code>
    <p>
      Parses the program's command-line arguments and stores any
      options that were set in a list
      of <a href="option.html"><code>Option</code></a> objects that
      can be accessed by iterating over the <code>OptionParser</code>
      using an iterator returned
      by <a href="#begin_end"><code>begin</code></a>
      or <a href="#find"><code>find</code></a>.
    </p>
    <p>
      Non-option program arguments are stored in a separate container
      that can be accessed with
      the <a href="#program_args"><code>program_args</code></a>
      method.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>argc</code></dt>
      <dd>The number of command-line arguments that were passed
      to <code>main</code>.</dd>
      <dt><code>argv</code></dt>
      <dd>The array of command-line arguments that was passed
      to <code>main</code>.</dd>
    </dl>

    <h2 id="size"><code>OptionParser::size</code></h2>

    <code>
      size_type size() const;
    </code>
    <p>
      Returns the size of the
      underlying <a href="option.html"><code>Option</code></a>
      container. That is, it returns the number of options that have
      been read from the command line.
    </p>

    <h4>Return Value</h4>
    <p>
      Number of options that have been read.
    </p>

    <h2 id="empty"><code>OptionParser::empty</code></h2>

    <code>
      bool empty() const;
    </code>
    <p>
      Checks whether the
      underlying <a href="option.html"><code>Option</code></a>
      container is empty. That is, it checks whether there have been
      no options read from the command line.
    </p>

    <h4>Return Value</h4>
    <p>
      True if the parser is empty (no options read) and false
      otherwise.
    </p>

    <h2 id="begin_end"><code>
        OptionParser::begin<br>
        OptionParser::end<br>
        OptionParser::rbegin<br>
        OptionParser::rend<br>
        OptionParser::cbegin<br>
        OptionParser::cend<br>
        OptionParser::crbegin<br>
        OptionParser::crend
    </code></h2>

    <code>
      iterator begin();<br>
      const_iterator begin() const;<br>
      iterator end();<br>
      const_iterator end() const;<br>
      <br>
      reverse_iterator rbegin();<br>
      const_reverse_iterator rbegin() const;<br>
      reverse_iterator rend();<br>
      const_reverse_iterator rend() const;<br>
      <br>
      const_iterator cbegin() const;<br>
      const_iterator cend() const;<br>
      <br>
      const_reverse_iterator crbegin() const;<br>
      const_reverse_iterator crend() const;
    </code>
    <p>
      The <code>begin</code> functions return an iterator to the
      beginning of the sequence of options that were read from the
      command line, and the <code>end</code> functions return an
      iterator to the end of the sequence (that is, an iterator
      pointing one element past the last option that was read).
    </p>
    <p>
      The <code>r</code> functions
      (<code>rbegin</code>, <code>rend</code>, <code>crbegin</code>,
      and <code>crend</code>) return reverse iterators and the
      functions whose names begin with '<code>c</code>' always
      return <code>const</code> iterators.
    </p>
    <h4>Return Value</h4>
    <p>
      An iterator pointing to the beginning or end of the sequence of
      options that were read from the command line (i.e., an iterator
      over the sequence
      of <a href="option.html"><code>Option</code></a> objects stored
      within the parser).
    </p>

    <h2 id="find"><code>OptionParser::find</code></h2>

    <code>
      iterator find(char short_name);<br>
      const_iterator find(char short_name) const;<br>
      iterator find(const std::string& long_name);<br>
      const_iterator find(const std::string& long_name) const;
    </code>
    <p>
      Searches the options that were read from the command line for a
      particular option and returns an iterator pointing to the
      appropriate <a href="option.html"><code>Option</code></a>
      object.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>short_name</code></dt>
      <dd>The short name of the option to be found.</dd>
      <dt><code>long_name</code></dt>
      <dd>The long name of the option to be found.</dd>
    </dl>

    <h4>Return Value</h4>
    <p>
      An iterator pointing to the
      first <a href="option.html"><code>Option</code></a> having the
      specified name, or an iterator to the end of the sequence if the
      option was not found.
    </p>

    <h2 id="program_args"><code>OptionParser::program_args</code></h2>

    <code>
      arg_seq& program_args();<br>
      const arg_seq& program_args() const;
    </code>
    <p>
      Returns a reference to a container holding all of the non-option
      program arguments that were read from the
      command-line. Non-option arguments are any of the arguments
      passed to <code>main</code> that do not start with a '-', except
      for those that are interpreted as the argument for an option, as
      well as any program arguments following a '--' argument.
    </p>
    <h4>Return Value</h4>
    <p>
      A reference to a container holding the non-option program
      arguments read from the command line.
    </p>

    <h2 id="print_usage"><code>OptionParser::print_usage</code></h2>

    <code>
      std::ostream& print_usage(std::ostream& out,
      unsigned tab_stop = 30,
      unsigned term_width = 80) const;
    </code>
    <p>
      Generate a help message consisting of descriptions for each
      option accepted by the program and print that message to a given
      output stream.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>out</code></dt>
      <dd>The output stream to which the help message is to be
        written.</dd>
      <dt><code>tab_stop</code></dt>
      <dd>The position within each line in the message string where
        the description text is to begin.</dd>
      <dt><code>term_width</code></dt>
      <dd>The maximum width of each line in the generated
      message string.</dd>
    </dl>

    <h4>Return Value</h4>
    <p>
      A reference to the output stream that was passed to
      the <code>out</code> parameter.
    </p>

    <h2 id="usage"><code>OptionParser::usage</code></h2>

    <code>
      void usage(std::string& opt_usage_str,
      unsigned tab_stop = 30,
      unsigned term_width = 80) const;
    </code>
    <p>
      Generate a help message consisting of descriptions for each
      option accepted by the program and store that message in the
      given <code>std::string</code>.
    </p>
    <h4>Parameters</h4>

    <dl>
      <dt><code>opt_usage_str</code></dt>
      <dd>The string in which the generated message should be
      stored.</dd>
      <dt><code>tab_stop</code></dt>
      <dd>The position within each line in the message string where
        the description text is to begin.</dd>
      <dt><code>term_width</code></dt>
      <dd>The maximum width of each line in the generated
      message string.</dd>
    </dl>
    
  </body>
</html>
